//@version=5
strategy("Simple MA+SQZMOM_LB_v1", overlay=true, initial_capital=10000, commission_type="percent", pyramiding=10, commission_value=0.01)

// Configuración del tamaño de compra
currentPrice = close 
amount_to_invest = 500 
qty_to_buy = amount_to_invest / currentPrice

// Configuración de EMAs
longEmaPeriod_B = 200
longEmaPeriod = 55

// Cálculo de las EMAs
longEma = ta.ema(close, longEmaPeriod)
longEma_B = ta.ema(close, longEmaPeriod_B)

// Dibujar las EMAs en el gráfico
plot(longEma_B, color=color.rgb(255, 0, 0), title="EMA 200", linewidth=2)
plot(longEma, color=color.rgb(255, 174, 0), title="EMA 55", linewidth=2)

// Permitir operaciones largas y cortas
allowLongs = true
allowShorts = true

// Periodo de tiempo activo para la estrategia
start_date = timestamp("2024-03-20 00:00 +0000")
end_date = timestamp("2024-12-01 12:00 +0000")

// Verifica si el tiempo actual está dentro del rango especificado
time_filter = (time >= start_date) and (time <= end_date)

// Cálculo del Squeeze Momentum Indicator (SMI) de LazyBear
lengthBB = input.int(20, title="Bollinger Bands Length")
multBB = input.float(2.0, title="Bollinger Bands MultFactor")
lengthKC = input.int(20, title="Keltner Channel Length")
multKC = input.float(1.5, title="Keltner Channel MultFactor")

// Bollinger Bands
source = close
basis = ta.sma(source, lengthBB)
dev = multBB * ta.stdev(source, lengthBB)
upperBB = basis + dev
lowerBB = basis - dev

// Keltner Channel
TrRange = ta.tr(true)
ma = ta.sma(source, lengthKC)
upperKC = ma + multKC * ta.sma(TrRange, lengthKC)
lowerKC = ma - multKC * ta.sma(TrRange, lengthKC)

// Squeeze
squeeze = (lowerBB > lowerKC) and (upperBB < upperKC)
noSqueeze = (lowerBB < lowerKC) and (upperBB > upperKC)

// Momentum
val = ta.linreg(source - ta.sma(source, lengthKC), lengthKC, 0)
hist = val - ta.sma(val, lengthKC)

// Señales de entrada y salida del SMI
exitSignal = ta.crossover(hist, 0) and squeeze

// Condiciones de cruce para entrada y salida
enterLong = ta.crossover(longEma, longEma_B) and time_filter
exitLong = exitSignal and time_filter

enterShort = ta.crossunder(longEma, longEma_B) and time_filter
exitShort = exitSignal and time_filter

// Función para formatear la fecha y hora
getTimeString() =>
    yearStr = str.tostring(year(time))
    monthStr = str.tostring(month(time))
    dayStr = str.tostring(dayofmonth(time))
    hourStr = str.tostring(hour(time))
    minuteStr = str.tostring(minute(time))
    secondStr = str.tostring(second(time))
    hourStr + ":" + minuteStr + ":" + secondStr + "_" + dayStr + "/" + monthStr + "/" + yearStr 

// Ejecutar las órdenes de la estrategia y generar alertas
if allowLongs and enterLong
    strategy.entry("Long", strategy.long, qty=qty_to_buy)
    alert('{"Ticker": "' + syminfo.ticker + '", "Temporalidad": "' + timeframe.period + '", "Quantity": "' + str.tostring(qty_to_buy) + '", "Entry Price Alert": "' + str.tostring(close) + '", "Time Alert": "' + getTimeString() + '", "Order": "Open Long", "Strategy": "MA Crossover"}', alert.freq_once_per_bar)
if allowLongs and exitLong
    strategy.close("Long")
    alert('{"Ticker": "' + syminfo.ticker + '", "Temporalidad": "' + timeframe.period + '", "Exit Price Alert": "' + str.tostring(close) + '", "Time Alert": "' + getTimeString() + '", "Order": "Close Long", "Strategy": "MA Crossover"}', alert.freq_once_per_bar)

if allowShorts and enterShort
    strategy.entry("Short", strategy.short, qty=qty_to_buy)
    alert('{"Ticker": "' + syminfo.ticker + '", "Temporalidad": "' + timeframe.period + '", "Quantity": "' + str.tostring(qty_to_buy) + '", "Entry Price Alert": "' + str.tostring(close) + '", "Time Alert": "' + getTimeString() + '", "Order": "Open Short", "Strategy": "MA Crossover"}', alert.freq_once_per_bar)
if allowShorts and exitShort
    strategy.close("Short")
    alert('{"Ticker": "' + syminfo.ticker + '", "Temporalidad": "' + timeframe.period + '", "Exit Price Alert": "' + str.tostring(close) + '", "Time Alert": "' + getTimeString() + '", "Order": "Close Short", "Strategy": "MA Crossover"}', alert.freq_once_per_bar)
